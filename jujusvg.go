package jujusvg

import (
	"image"
	"io/ioutil"
	"net/http"
	"sort"
	"strconv"
	"strings"

	"gopkg.in/errgo.v1"
	"gopkg.in/juju/charm.v5-unstable"
)

// An IconFetcher provides functionality for retrieving icons for the charms
// within a given bundle.  The FetchIcons function accepts a bundle, and
// returns a dict mapping charm paths to icon data.
type IconFetcher interface {
	FetchIcons(*charm.BundleData) (map[string]string, error)
}

// HttpFetcher is a default implementation of IconFetcher which retrieves charm
// icons from the web using the URL generated by IconURL on that charm.  The
// HTTP Client used may be overridden by an instance of http.Client.  The icons
// may optionally be fetched concurrently.
type HttpFetcher struct {
	FetchConcurrently bool
	IconURL           func(*charm.Reference) string
	Client            *http.Client
}

// FetchIcons retrieves icon SVGs over HTTP.  If specified in the struct, icons
// will be fetched concurrently.
func (h *HttpFetcher) FetchIcons(b *charm.BundleData) (map[string]string, error) {
	// If a client was not provided on creation, set a default.
	if h.Client == nil {
		h.Client = new(http.Client)
	}

	// Maintain a list of icons that have already been fetched.
	alreadyFetched := make(map[string]bool)

	// Channels for concurrent fetching.
	channels := [](chan bool){}
	errors := make(chan error, len(b.Services))

	// Build the map of icons.
	icons := make(map[string]string)
	for _, serviceData := range b.Services {
		charmId, err := charm.ParseReference(serviceData.Charm)
		if err != nil {
			return nil, errgo.Notef(err, "cannot parse charm %q", serviceData.Charm)
		}
		path := charmId.Path()

		// Don't duplicate icons in the map.
		if !alreadyFetched[path] {
			alreadyFetched[path] = true

			// Fetch concurrently or not, depending on option.
			if h.FetchConcurrently {
				done := make(chan bool, 1)
				channels = append(channels, done)
				go func() {
					icon, err := h.fetchIcon(h.IconURL(charmId), done)
					if err != nil {
						errors <- err
					} else {
						icons[path] = icon
					}
				}()
			} else {
				icon, err := h.fetchIcon(h.IconURL(charmId), nil)
				if err != nil {
					return nil, err
				}
				icons[path] = icon
			}
		}
	}

	// If fetching concurrently, block on receiving icon data; if any errors
	// occured, report them.
	if h.FetchConcurrently {
		for _, ch := range channels {
			<-ch
		}
		close(errors)
		for err := range errors {
			if err != nil {
				return nil, err
			}
		}
	}
	return icons, nil
}

// fetchIcon retrieves a single icon svg over HTTP.
func (h *HttpFetcher) fetchIcon(url string, done chan bool) (string, error) {
	resp, err := h.Client.Get(url)
	if err != nil {
		return "", errgo.Newf("HTTP error fetching %s: %v", url, err)
	}
	defer resp.Body.Close()
	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return "", errgo.Newf("could not read icon data from url %s", url)
	}
	if done != nil {
		done <- true
	}
	return string(body), nil
}

// NewFromBundle returns a new Canvas that can be used
// to generate a graphical representation of the given bundle
// data. The iconURL function is used to generate a URL
// that refers to an SVG for the supplied charm URL.  If
// requested, icon SVGs that are available will be embedded
// within the bundle SVG so that the bundle will be self-
// contained as much as possible.  If that is to be the case,
// utilize the provided IconFetcher (or default to HttpFetcher
// if nil) to retrieve the icons.
func NewFromBundle(b *charm.BundleData, iconURL func(*charm.Reference) string, embedIcons bool, fetcher IconFetcher) (*Canvas, error) {
	if embedIcons {
		if fetcher == nil {
			fetcher = &HttpFetcher{
				FetchConcurrently: true,
				IconURL:           iconURL,
			}
		}
		iconMap, err := fetcher.FetchIcons(b)
		if err != nil {
			return nil, err
		}
		return newFromBundleWithMap(b, iconURL, iconMap)
	} else {
		return newFromBundleWithMap(b, iconURL, map[string]string{})
	}
}

// newFromBundleWithMap returns a new Canvas that can be used
// to generate a graphical representation of the given bundle
// data. The iconURL function is used to generate a URL
// that refers to an SVG for the supplied charm URL. If a map
// of charms to icon SVGs is provided, then those SVGs will be
// embedded in the bundle diagram and used instead of an image
// tag.
func newFromBundleWithMap(b *charm.BundleData, iconURL func(*charm.Reference) string, iconMap map[string]string) (*Canvas, error) {
	var canvas Canvas

	// Verify the bundle to make sure that all the invariants
	// that we depend on below actually hold true.
	if err := b.Verify(nil); err != nil {
		return nil, errgo.Notef(err, "cannot verify bundle")
	}
	// Go through all services in alphabetical order so that
	// we get consistent results.
	serviceNames := make([]string, 0, len(b.Services))
	for name := range b.Services {
		serviceNames = append(serviceNames, name)
	}
	sort.Strings(serviceNames)
	services := make(map[string]*service)
	for _, name := range serviceNames {
		serviceData := b.Services[name]
		x, xerr := strconv.ParseFloat(serviceData.Annotations["gui-x"], 64)
		y, yerr := strconv.ParseFloat(serviceData.Annotations["gui-y"], 64)
		if xerr != nil || yerr != nil {
			return nil, errgo.Newf("service %q does not have a valid position", name)
		}
		charmId, err := charm.ParseReference(serviceData.Charm)
		if err != nil {
			// cannot actually happen, as we've verified it.
			return nil, errgo.Notef(err, "cannot parse charm %q", serviceData.Charm)
		}
		icon, _ := iconMap[charmId.Path()]
		svc := &service{
			name:      name,
			charmPath: charmId.Path(),
			point:     image.Point{int(x), int(y)},
			iconUrl:   iconURL(charmId),
			iconSrc:   icon,
		}
		services[name] = svc
		canvas.addService(svc)
	}
	for _, relation := range b.Relations {
		canvas.addRelation(&serviceRelation{
			serviceA: services[strings.Split(relation[0], ":")[0]],
			serviceB: services[strings.Split(relation[1], ":")[0]],
		})
	}
	return &canvas, nil
}
