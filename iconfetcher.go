package jujusvg

import (
	"fmt"
	"io/ioutil"
	"net/http"
	"sync"

	"gopkg.in/errgo.v1"
	"gopkg.in/juju/charm.v5-unstable"
)

// An IconFetcher provides functionality for retrieving icons for the charms
// within a given bundle.  The FetchIcons function accepts a bundle, and
// returns a dict mapping charm paths to icon data.
type IconFetcher interface {
	FetchIcons(*charm.BundleData) (map[string]string, error)
}

// LinkFetcher fetches icons as links so that they are included within the SVG
// as remote resources.
type LinkFetcher struct {
	IconURL func(*charm.Reference) string
}

// FetchIcons generates the svg image tags given an appropriate URL, generating
// tags only for unique icons.
func (l *LinkFetcher) FetchIcons(b *charm.BundleData) (map[string]string, error) {
	// Maintain a list of icons that have already been fetched.
	alreadyFetched := make(map[string]bool)

	// Build the map of icons.
	icons := make(map[string]string)
	for _, serviceData := range b.Services {
		charmId, err := charm.ParseReference(serviceData.Charm)
		if err != nil {
			return nil, errgo.Notef(err, "cannot parse charm %q", serviceData.Charm)
		}
		path := charmId.Path()

		// Don't duplicate icons in the map.
		if !alreadyFetched[path] {
			alreadyFetched[path] = true
			icons[path] = fmt.Sprintf(`
				<svg xlmns=%q xmlns:xlink="http://www.w3.org/1999/xlink">
					<image width="96" height="96" xlink:href=%q />
				</svg>`, svgNamespace, l.IconURL(charmId))
		}
	}
	return icons, nil
}

// HTTPFetcher is an implementation of IconFetcher which retrieves charm
// icons from the web using the URL generated by IconURL on that charm.  The
// HTTP Client used may be overridden by an instance of http.Client.  The icons
// may optionally be fetched concurrently.
type HTTPFetcher struct {
	FetchConcurrently bool
	IconURL           func(*charm.Reference) string
	Client            *http.Client
}

// FetchIcons retrieves icon SVGs over HTTP.  If specified in the struct, icons
// will be fetched concurrently.
func (h *HTTPFetcher) FetchIcons(b *charm.BundleData) (map[string]string, error) {
	// If a client was not provided on creation, set a default.
	if h.Client == nil {
		h.Client = new(http.Client)
	}

	// Maintain a list of icons that have already been fetched.
	alreadyFetched := make(map[string]bool)

	// WaitGroup and channels for concurrent fetching.
	var wg sync.WaitGroup
	errors := make(chan error, len(b.Services))

	// Build the map of icons.
	icons := make(map[string]string)
	for _, serviceData := range b.Services {
		charmId, err := charm.ParseReference(serviceData.Charm)
		if err != nil {
			return nil, errgo.Notef(err, "cannot parse charm %q", serviceData.Charm)
		}
		path := charmId.Path()

		// Don't duplicate icons in the map.
		if !alreadyFetched[path] {
			alreadyFetched[path] = true

			// Fetch concurrently or not, depending on option.
			if h.FetchConcurrently {
				wg.Add(1)
				go func() {
					defer wg.Done()
					icon, err := h.fetchIcon(h.IconURL(charmId))
					if err != nil {
						errors <- err
					} else {
						icons[path] = icon
					}
				}()
			} else {
				icon, err := h.fetchIcon(h.IconURL(charmId))
				if err != nil {
					return nil, err
				}
				icons[path] = icon
			}
		}
	}

	// If fetching concurrently, block on receiving icon data; if any errors
	// occured, report them.
	if h.FetchConcurrently {
		wg.Wait()
		close(errors)
		for err := range errors {
			if err != nil {
				return nil, err
			}
		}
	}
	return icons, nil
}

// fetchIcon retrieves a single icon svg over HTTP.
func (h *HTTPFetcher) fetchIcon(url string) (string, error) {
	resp, err := h.Client.Get(url)
	if err != nil {
		return "", errgo.Newf("HTTP error fetching %s: %v", url, err)
	}
	defer resp.Body.Close()
	if resp.StatusCode != http.StatusOK {
		return "", errgo.Newf("error retrieving icon from %s: %s", url, resp.Status)
	}
	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return "", errgo.Newf("could not read icon data from url %s", url)
	}
	return string(body), nil
}
